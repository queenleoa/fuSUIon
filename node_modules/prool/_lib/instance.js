import { EventEmitter } from 'eventemitter3';
/**
 * Creates an instance definition.
 *
 * @param fn - Function to define the instance.
 *
 * @example
 * ```ts
 * const foo = defineInstance((parameters: FooParameters) => {
 *  return {
 *    name: 'foo',
 *    host: 'localhost',
 *    port: 3000,
 *    async start() {
 *      // ...
 *    },
 *    async stop() {
 *      // ...
 *    },
 *  }
 * })
 * ```
 */
export function defineInstance(fn) {
    return (...[parametersOrOptions, options_]) => {
        function create(createParameters = {}) {
            const parameters = parametersOrOptions;
            const options = options_ || parametersOrOptions || {};
            const { _internal, host, name, port, start, stop } = {
                ...fn(parameters),
                ...createParameters,
            };
            const { messageBuffer = 20, timeout } = options;
            let restartResolver = Promise.withResolvers();
            let startResolver = Promise.withResolvers();
            let stopResolver = Promise.withResolvers();
            const emitter = new EventEmitter();
            let messages = [];
            let status = 'idle';
            let restarting = false;
            function onExit() {
                status = 'stopped';
            }
            function onListening() {
                status = 'started';
            }
            function onMessage(message) {
                messages.push(message);
                if (messages.length > messageBuffer)
                    messages.shift();
            }
            return {
                _internal: _internal,
                messages: {
                    clear() {
                        messages = [];
                    },
                    get() {
                        return messages;
                    },
                },
                host,
                name,
                port,
                get status() {
                    if (restarting)
                        return 'restarting';
                    return status;
                },
                async start() {
                    if (status === 'starting')
                        return startResolver.promise;
                    if (status !== 'idle' && status !== 'stopped')
                        throw new Error(`Instance "${name}" is not in an idle or stopped state. Status: ${status}`);
                    if (typeof timeout === 'number') {
                        const timer = setTimeout(() => {
                            clearTimeout(timer);
                            startResolver.reject(new Error(`Instance "${name}" failed to start in time.`));
                        }, timeout);
                    }
                    emitter.on('message', onMessage);
                    emitter.on('listening', onListening);
                    emitter.on('exit', onExit);
                    status = 'starting';
                    start({
                        port,
                    }, {
                        emitter,
                        status: this.status,
                    })
                        .then(() => {
                        status = 'started';
                        stopResolver = Promise.withResolvers();
                        startResolver.resolve(this.stop.bind(this));
                    })
                        .catch((error) => {
                        status = 'idle';
                        this.messages.clear();
                        emitter.off('message', onMessage);
                        startResolver.reject(error);
                    });
                    return startResolver.promise;
                },
                async stop() {
                    if (status === 'stopping')
                        return stopResolver.promise;
                    if (status === 'starting')
                        throw new Error(`Instance "${name}" is starting.`);
                    if (typeof timeout === 'number') {
                        const timer = setTimeout(() => {
                            clearTimeout(timer);
                            stopResolver.reject(new Error(`Instance "${name}" failed to stop in time.`));
                        }, timeout);
                    }
                    status = 'stopping';
                    stop({
                        emitter,
                        status: this.status,
                    })
                        .then((...args) => {
                        status = 'stopped';
                        this.messages.clear();
                        emitter.off('message', onMessage);
                        emitter.off('listening', onListening);
                        emitter.off('exit', onExit);
                        startResolver = Promise.withResolvers();
                        stopResolver.resolve(...args);
                    })
                        .catch((error) => {
                        status = 'started';
                        stopResolver.reject(error);
                    });
                    return stopResolver.promise;
                },
                async restart() {
                    if (restarting)
                        return restartResolver.promise;
                    restarting = true;
                    this.stop()
                        .then(() => this.start.bind(this)())
                        .then(() => restartResolver.resolve())
                        .catch(restartResolver.reject)
                        .finally(() => {
                        restartResolver = Promise.withResolvers();
                        restarting = false;
                    });
                    return restartResolver.promise;
                },
                addListener: emitter.addListener.bind(emitter),
                off: emitter.off.bind(emitter),
                on: emitter.on.bind(emitter),
                once: emitter.once.bind(emitter),
                removeListener: emitter.removeListener.bind(emitter),
                removeAllListeners: emitter.removeAllListeners.bind(emitter),
            };
        }
        return Object.assign(create(), { create });
    };
}
//# sourceMappingURL=instance.js.map