import { createServer as createServer_, } from 'node:http';
import httpProxy from 'http-proxy';
import { definePool } from './pool.js';
import { extractPath } from './utils.js';
const { createProxyServer } = httpProxy;
/**
 * Creates a server that manages a pool of instances via a proxy.
 *
 * @example
 * ```
 * import { createServer } from 'prool'
 * import { anvil } from 'prool/instances'
 *
 * const server = createServer({
 *  instance: anvil(),
 * })
 *
 * const server = await server.start()
 * // Instances accessible at:
 * // "http://localhost:8545/1"
 * // "http://localhost:8545/2"
 * // "http://localhost:8545/3"
 * // "http://localhost:8545/n"
 * // "http://localhost:8545/n/start"
 * // "http://localhost:8545/n/stop"
 * // "http://localhost:8545/n/restart"
 * // "http://localhost:8545/healthcheck"
 * ```
 */
export function createServer(parameters) {
    const { host = '::', instance, limit, port } = parameters;
    const pool = definePool({ instance, limit });
    const proxy = createProxyServer({
        ignorePath: true,
        ws: true,
    });
    const server = createServer_(async (request, response) => {
        try {
            const url = request.url;
            if (!url) {
                response.end();
                return;
            }
            const { id, path } = extractPath(url);
            if (typeof id === 'number') {
                if (path === '/') {
                    const { host, port } = pool.get(id) || (await pool.start(id));
                    return proxy.web(request, response, {
                        target: `http://${host}:${port}`,
                    });
                }
                if (path === '/destroy') {
                    await pool.destroy(id);
                    return done(response, 200);
                }
                if (path === '/start') {
                    const { host, port } = await pool.start(id);
                    return done(response, 200, { host, port });
                }
                if (path === '/stop') {
                    await pool.stop(id);
                    return done(response, 200);
                }
                if (path === '/restart') {
                    await pool.restart(id);
                    return done(response, 200);
                }
                if (path === '/messages') {
                    const messages = pool.get(id)?.messages.get() || [];
                    return done(response, 200, messages);
                }
            }
            if (path === '/healthcheck')
                return done(response, 200);
            return done(response, 404);
        }
        catch (error) {
            return done(response, 400, { message: error.message });
        }
    });
    proxy.on('proxyReq', (proxyReq, req) => {
        ;
        req._proxyReq = proxyReq;
    });
    proxy.on('error', (err, req) => {
        if (req.socket.destroyed && err.code === 'ECONNRESET') {
            ;
            req._proxyReq.abort();
        }
    });
    server.on('upgrade', async (request, socket, head) => {
        const url = request.url;
        if (!url) {
            socket.destroy(new Error('Unsupported request'));
            return;
        }
        const { id, path } = extractPath(url);
        if (typeof id === 'number' && path === '/') {
            const { host, port } = pool.get(id) || (await pool.start(id));
            proxy.ws(request, socket, head, {
                target: `ws://${host}:${port}`,
            });
            return;
        }
        socket.destroy(new Error('Unsupported request'));
        return;
    });
    return Object.assign(server, {
        start() {
            return new Promise((resolve) => {
                if (port)
                    server.listen(port, host, () => resolve(this.stop));
                else
                    server.listen(() => resolve(this.stop));
            });
        },
        async stop() {
            await Promise.allSettled([
                new Promise((resolve, reject) => server.close((error) => (error ? reject(error) : resolve()))),
                pool.destroyAll(),
            ]);
        },
    });
}
function done(res, statusCode, json) {
    return res
        .writeHead(statusCode, { 'Content-Type': 'application/json' })
        .end(json ? JSON.stringify(json) : undefined);
}
//# sourceMappingURL=server.js.map